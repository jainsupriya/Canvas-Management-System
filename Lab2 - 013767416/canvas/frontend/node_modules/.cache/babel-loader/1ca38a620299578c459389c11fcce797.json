{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _noGetters = require('react-lazy-cache/noGetters');\n\nvar _noGetters2 = _interopRequireDefault(_noGetters);\n\nvar _getDisplayName = require('./getDisplayName');\n\nvar _getDisplayName2 = _interopRequireDefault(_getDisplayName);\n\nvar _createHigherOrderComponent = require('./createHigherOrderComponent');\n\nvar _createHigherOrderComponent2 = _interopRequireDefault(_createHigherOrderComponent);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * This component tracks props that affect how the form is mounted to the store. Normally these should not change,\n * but if they do, the connected components below it need to be redefined.\n */\n\n\nvar createReduxFormConnector = function createReduxFormConnector(isReactNative, React, connect) {\n  return function (WrappedComponent, mapStateToProps, mapDispatchToProps, mergeProps, options) {\n    var Component = React.Component;\n\n    var _ref = options || {},\n        _ref$withRef = _ref.withRef,\n        withRef = _ref$withRef === undefined ? false : _ref$withRef;\n\n    var ReduxFormConnector = function (_Component) {\n      _inherits(ReduxFormConnector, _Component);\n\n      function ReduxFormConnector(props) {\n        _classCallCheck(this, ReduxFormConnector);\n\n        var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n        _this.cache = new _noGetters2.default(_this, {\n          ReduxForm: {\n            params: [// props that effect how redux-form connects to the redux store\n            'reduxMountPoint', 'form', 'formKey', 'getFormState'],\n            fn: (0, _createHigherOrderComponent2.default)(props, isReactNative, React, connect, WrappedComponent, mapStateToProps, mapDispatchToProps, mergeProps, options)\n          }\n        });\n        return _this;\n      }\n\n      ReduxFormConnector.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n        this.cache.componentWillReceiveProps(nextProps);\n      };\n\n      ReduxFormConnector.prototype.render = function render() {\n        var ReduxForm = this.cache.get('ReduxForm'); // remove some redux-form config-only props\n\n        var _props = this.props,\n            reduxMountPoint = _props.reduxMountPoint,\n            destroyOnUnmount = _props.destroyOnUnmount,\n            form = _props.form,\n            getFormState = _props.getFormState,\n            touchOnBlur = _props.touchOnBlur,\n            touchOnChange = _props.touchOnChange,\n            passableProps = _objectWithoutProperties(_props, ['reduxMountPoint', 'destroyOnUnmount', 'form', 'getFormState', 'touchOnBlur', 'touchOnChange']); // eslint-disable-line no-redeclare\n\n\n        if (withRef) {\n          return React.createElement(ReduxForm, _extends({}, passableProps, {\n            ref: 'wrappedInstance'\n          }));\n        }\n\n        return React.createElement(ReduxForm, passableProps);\n      };\n\n      return ReduxFormConnector;\n    }(Component);\n\n    ReduxFormConnector.displayName = 'ReduxFormConnector(' + (0, _getDisplayName2.default)(WrappedComponent) + ')';\n    ReduxFormConnector.WrappedComponent = WrappedComponent;\n    ReduxFormConnector.propTypes = {\n      destroyOnUnmount: _propTypes2.default.bool,\n      reduxMountPoint: _propTypes2.default.string,\n      form: _propTypes2.default.string.isRequired,\n      formKey: _propTypes2.default.string,\n      getFormState: _propTypes2.default.func,\n      touchOnBlur: _propTypes2.default.bool,\n      touchOnChange: _propTypes2.default.bool\n    };\n    ReduxFormConnector.defaultProps = {\n      reduxMountPoint: 'form',\n      getFormState: function getFormState(state, reduxMountPoint) {\n        return state[reduxMountPoint];\n      }\n    };\n    return ReduxFormConnector;\n  };\n};\n\nexports.default = createReduxFormConnector;","map":null,"metadata":{},"sourceType":"script"}